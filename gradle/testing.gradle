import edu.ucar.build.OpenedFilesListener
import edu.ucar.build.tasks.FilterOpenedFilesTask
import java.nio.file.Files
import java.nio.file.Paths

// The log messages in this ext block will be emitted every time we build, even if no Test task is being run.
// That's a bit spammy, but at least the code is straightforward.
// The alternative is to use "gradle.taskGraph.whenReady{}" and only do this config if a Test is in the task graph,
// but it's not worth the extra complication.
ext {
    // These appear to be the only environment variables that Jenkins defines: http://goo.gl/iCh08k
    // Is there a better way to detect Jenkins?
    jenkinsEnvVar = 'JENKINS_URL'
    isJenkins = System.env[jenkinsEnvVar] as boolean  // We only care if prop is defined, not its actual value.

    if (isJenkins) {
        logger.warn "Skipping all NotJenkins tests: detected that we're running in the Jenkins environment."
    }


    travisEnvVar = 'TRAVIS'
    isTravis = System.env[travisEnvVar] as boolean  // We only care if prop is defined, not its actual value.

    if (isTravis) {
        logger.warn "Skipping all NotTravis tests: detected that we're running in the Travis environment."
    }


    contentRootKey = 'tds.content.root.path'
    isContentRootAvailable = isSystemPropertyAValidDirectory contentRootKey

    if (!isContentRootAvailable && !isJenkins) {        // Don't skip tests on Jenkins, except NotJenkins ones.
        logger.warn "Skipping all NeedsContentRoot tests."
    }


    testdataDirKey = 'unidata.testdata.path'
    isCdmUnitTestDirAvailable = isSystemPropertyAValidDirectory testdataDirKey

    if (!isCdmUnitTestDirAvailable && !isJenkins) {     // Don't skip tests on Jenkins, except NotJenkins ones.
        logger.warn "Skipping all NeedsCdmUnitTest tests."
    }

    isRdaDataAvailable = false  // figure out how to set later

    // Do not propagate these system properties to the Gradle test executors.
    systemPropertiesBlackList = [
        // Passing this causes "java.lang.ClassNotFoundException: org.jacoco.agent.rt.internal_932a715.PreMain"
        // See https://discuss.gradle.org/t/jacoco-related-failure-in-multiproject-build/6216
        'user.dir',

        // Gradle is also using JNA and it sets this property when it runs. However, it is an old, incompatible version
        // (3.2.7). We'll fail to load NetCDF-C if we try to do it using JNA v3.
        // What we want is for JNA to look in the JNA jar file for the lib, which it'll do if this prop is *undefined*.
        // See http://twall.github.io/jna/4.1.0/overview-summary.html#loading
        'jna.boot.library.path'
    ]
}

/**
 * Returns {@code true} if the given system property is defined and denotes an existing directory. Otherwise,
 * {@code false} is returned and the property is set to {@code "$buildDir/NO/$sysPropKey/FOUND/"}.
 *
 * @param sysPropKey  the name of a system property. It'll likely have been set either on the command line or in
 *                    gradle.properties.
 * @return  {@code true} if the given system property is defined and denotes an existing directory.
 */
boolean isSystemPropertyAValidDirectory(String sysPropKey) {
    String sysPropVal = System.properties[sysPropKey]

    if (sysPropVal) {
        if (Files.isDirectory(Paths.get(sysPropVal))) {
            return true
        } else {
            logger.warn "$sysPropKey=\"$sysPropVal\"; system property is not a directory."
        }
    } else {
        logger.warn "\"$sysPropKey\" system property not defined."
    }

    // Initialization for our tests requires that we define SOME value for 'tds.content.root.path' and
    // 'unidata.testdata.path'. To clearly indicate that the property wasn't set properly by the user, we're going to
    // create a path containing the segment "NO/$sysPropKey/FOUND".
    //
    // However, we must exercise some care in our choice of parent directory for that segment. This is because when we
    // start the embedded TDS server for :it:integrationTest, log4j will attempt to create the directory
    // "${sys:tds.content.root.path}/thredds/logs" (see TDS's log4j.xml). In the event that the user fails to define
    // that property, the responsible place to create this logs directory is under the project build directory.
    String defaultSysPropVal = Paths.get(buildDir.path, "NO", sysPropKey, "FOUND").toAbsolutePath().toString()

    logger.info "Setting default system property: $sysPropKey=\"$defaultSysPropVal\""
    System.properties[sysPropKey] = defaultSysPropVal
    return false
}


configure(testedProjects) {
    apply plugin: 'java'
    apply from: "$rootDir/gradle/dependencies.gradle"

    dependencies {
        testCompile project(":testUtil")  // Contains stuff like the JUnit @Category classes.
        testCompile libraries["junit"]
    }

    tasks.withType(Test).all {
        // Propagates system properties set on the Gradle process to the test executors.
        System.properties.each { key, value ->
            if (!systemPropertiesBlackList.contains(key) &&
                    !systemProperties.containsKey(key)) {  // Don't overrwrite any existing entries.
                systemProperties[key] = value
            }
        }

        if (isTravis) {
            ignoreFailures = false  // On Travis, abort the build if any tests fail.
        } else {
            ignoreFailures = true   // In every other environment, don't let test failures abort the build.
        }

        useJUnit {
            if (isJenkins) {
                excludeCategories 'ucar.unidata.util.test.category.NotJenkins'
            }

            if (isTravis) {
                excludeCategories 'ucar.unidata.util.test.category.NotTravis'
                excludeCategories 'ucar.unidata.util.test.category.NeedsExternalResource'
            }

            if (!isContentRootAvailable && !isJenkins) {     // Don't skip tests on Jenkins, except NotJenkins ones.
                excludeCategories 'ucar.unidata.util.test.category.NeedsContentRoot'
            }

            if (!isCdmUnitTestDirAvailable && !isJenkins) {  // Don't skip tests on Jenkins, except NotJenkins ones.
                excludeCategories 'ucar.unidata.util.test.category.NeedsCdmUnitTest'
            }

            if (!isRdaDataAvailable) {
                excludeCategories 'ucar.unidata.util.test.category.NeedsRdaData'
            }
        }
    }

    Project subproject = delegate as Project

    // Add an SLF4J binding to testRuntime, if necessary.
    afterEvaluate {
        if (testRuntimeHasDepNamed(subproject, "slf4j-api")) {
            if (!testRuntimeHasDepNamed(subproject, "slf4j-jdk14") &&
                    !testRuntimeHasDepNamed(subproject, "log4j-slf4j-impl")) {
                logger.info "Using default binding (slf4j-jdk14) to log testing messages in '$subproject.path'."
                dependencies.testRuntime libraries["slf4j-jdk14"]
            }
        }
    }
}

boolean testRuntimeHasDepNamed(Project project, String depName) {
    try {
        // Groovy truth: empty collections are coerced to false.
        project.configurations.testRuntime.allDependencies.findAll { it.name == depName }
    } catch (UnknownConfigurationException e) {  // Project did not have a configuration named 'testRuntime'.
        logger.debug e.message
        false
    }
}

/////////////////////////// cdmUnitTest/ opened-files report ///////////////////////////

ext.reportOnCdmUnitTestFilesOpened = true

if (reportOnCdmUnitTestFilesOpened) {
    configure(testedProjects) {
        configurations {
            testAgent { transitive = false }  // See note below.
        }

        dependencies {
            // We want to instrument the Gradle test executor JVM with file-leak-detector. We do this by using
            // the -javaagent switch (see https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/
            // package-summary.html#package.description). The switch requires that the agent and its dependencies
            // be contained within a single jar.
            //
            // Luckily, a fat jar is available on Maven Central. We add it to its own configuration (testAgent)
            // that is NON-transitive. Non-transitivity is important because the Gradle dependency machinery is
            // processing the regular (and only) file-leak-detector POM. That POM assumes usage of the skinny jar
            // and declares dependencies that we don't need because they're already packaged in the fat jar.
            testAgent libraries["file-leak-detector-fatJar"]

            // Add the classes from :buildSrc to the testRuntime classpath. Specifically, we need to make
            // edu.ucar.build.OpenedFileList available to the test JVM. Given that the output of :buildSrc is
            // implicitly added to the buildscript classpaths of other subprojects, you'd think there'd be a less
            // kludgy way to accomplish this, but apparently not: http://stackoverflow.com/questions/22633813.
            // In any event, :buildSrc:assemble is guaranteed to have run by this point in the build, so the
            // addition is safe.
            testRuntime rootProject.files('buildSrc/build/classes/main')
        }

        File openedFilesReport = file("${testReportDir}/opened-files-report.ser.gz")

        tasks.withType(Test).all {
            outputs.file openedFilesReport
            systemProperties[OpenedFilesListener.REPORT_FILE_KEY] = openedFilesReport

            // Delay resolution of testAgent configuration until execution phase. This avoids the error:
            // "Cannot change dependencies of configuration $name after it has been resolved" in
            // dependencies.gradle.
            doFirst {
                // set arguments for the test executor JVM.
                jvmArgs "-javaagent:${configurations.testAgent.singleFile}=" +
                        "listener=${OpenedFilesListener.name}"  // From :buildSrc
            }
        }

        task filterOpenedFiles(type: FilterOpenedFilesTask, group: 'Verification') {
            unfilteredRecordsFile = openedFilesReport
            hitsDestFile   = file("${testReportDir}/opened-files-report-hits.txt")
            missesDestFile = file("${testReportDir}/opened-files-report-misses.txt")

            if (isCdmUnitTestDirAvailable) {
                addOpenedFilesToReportOn fileTree(new File(System.properties[testdataDirKey]))
            }

            if (plugins.hasPlugin('java')) {
                addSourceFilesToReportOn sourceSets.test.java
            }
            if (plugins.hasPlugin('groovy')) {
                addSourceFilesToReportOn sourceSets.test.groovy
            }

            openedFilesIgnorePatterns << ~/.+\.jar$/
            openedFilesIgnorePatterns << ~/.+\.class$/
        }
    }
}

///////////////////////////////////////////////// Root tasks /////////////////////////////////////////////////

gradle.projectsEvaluated {
    configure (rootProject) {
        // By default, subprojects are evaluated AFTER their parents, meaning that the full set of subproject Test
        // tasks won't be available until all subprojects have been evaluated. That's why we've delayed the
        // configuration of the following two rootProject tasks.
        Set<Task> subprojectTestTasks = subprojects*.tasks*.withType(Test).flatten()

        task testAll(group: 'Verification') {
            description = 'Runs all subproject Test tasks'
            dependsOn subprojectTestTasks
        }

        task rootTestReport(type: TestReport, group: 'Reports') {
            description = 'Generates an aggregate test report'
            destinationDir = file("$buildDir/reports/allTests")

            // All Test tasks will be finalized by this task. As a result, this task needn't be invoked directly.
            subprojectTestTasks*.finalizedBy it

            // :buildSrc:test always runs and produces a binary results directory, no matter what.
            assert file('buildSrc/build/test-results/binary/test').exists() : "Can't find :buildSrc test result dir."

            // Add test results of the :buildSrc project. Note that by this time in the 'thredds' config,
            // :buildSrc has already run as a *separate* build (see http://stackoverflow.com/questions/26597147),
            // so we cannot programmatically access its Project object to retrieve this paths.
            reportOn file('buildSrc/build/test-results/binary/test')

            // We could also do "reportOn subprojectTestTasks" here, but that would cause this task to be dependent on
            // all subproject Tests. So, we couldn't do something like ":grib:test" and expect only GRIB tests to run
            // because:
            //     ":grib:test" --finalizedBy--> ":rootTestReport" --dependsOn--> "all_subproject_Tests"
            // In other words, all subproject tests would get run, no matter what.
            // Passing File arguments to reportOn() instead doesn't create that dependency.
            reportOn subprojectTestTasks*.binResultsDir

            // Wait until all Test tasks have run. This creates a task *ordering*, not a dependency.
            mustRunAfter subprojectTestTasks
        }
    }
}

apply plugin: "base"  // Gives us the "clean" task for removing rootTestReport's output.
